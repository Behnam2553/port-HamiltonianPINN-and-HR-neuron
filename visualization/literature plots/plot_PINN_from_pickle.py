"""
plot_PINN_from_pickle.py
-------------------------
This script loads the curated time-series and loss data from the
'pinn_plot_data.pkl' file generated by pH_PINN.py and reproduces all
the final analysis and comparison plots.

This allows for visualization to be run independently from model training.
"""

import pickle
import os
import numpy as np
import matplotlib.pyplot as plt


def main():
    """
    Loads the pickle data and generates all plots.
    """
    # ==========================================================================
    # 1. SETUP PATHS AND LOAD DATA
    # ==========================================================================

    # Define paths relative to this script's location
    # This script is in (root)/visualization/literature plots/
    # The data is in (root)/results/PINN Data/
    script_dir = os.path.dirname(os.path.abspath(__file__))
    pickle_path = os.path.join(script_dir, '..', '..', 'results', 'PINN Data', 'pinn_plot_data.pkl')
    output_dir = os.path.join(script_dir, '..', '..', 'results', 'PINN Plots')
    os.makedirs(output_dir, exist_ok=True)

    print(f"Loading plotting data from: {pickle_path}")
    try:
        with open(pickle_path, 'rb') as f:
            data = pickle.load(f)
        print("Data loaded successfully.")
    except FileNotFoundError:
        print(f"ERROR: Data file not found at '{pickle_path}'")
        print("Please run the pH_PINN.py script first to generate the data file.")
        return

    # ==========================================================================
    # 2. UNPACK DATA FROM DICTIONARY
    # ==========================================================================

    # Unpack all variables from the dictionary for easier access
    t_test = data['t_test']
    # split_start = data['split_start']
    # split_end = data['split_end']

    split_start = 0
    split_end = 200000

    # Loss Histories
    train_losses = data['train_losses']
    val_losses = data['val_losses']
    hamiltonian_losses = data['hamiltonian_losses']
    phys_losses = data['phys_losses']
    conservative_losses = data['conservative_losses']
    dissipative_losses = data['dissipative_losses']
    j_structure_losses = data['j_structure_losses']
    r_structure_losses = data['r_structure_losses']

    # Plot Data
    H_analytical_vis = data['H_analytical_vis']
    H_learned_aligned = data['H_learned_aligned']
    e_dot_test = data['e_dot_test']
    e_dot_from_equations = data['e_dot_from_equations']
    e_dot_from_structure = data['e_dot_from_structure']
    dHdt_analytical_vis = data['dHdt_analytical_vis']
    dHdt_pred_true = data['dHdt_pred_true']
    dHdt_pred_pH = data['dHdt_pred_pH']

    print("All required data has been unpacked.")

    # ==========================================================================
    # 3. GENERATE PLOTS
    # ==========================================================================
    print("Generating plots...")

    # --- Plot 1: Learned vs Analytical Hamiltonian ---
    plt.figure(figsize=(12, 8))
    plt.plot(t_test[split_start:split_end], H_analytical_vis[split_start:split_end],
             label='Analytical Hamiltonian', color='blue', linewidth=3)
    plt.plot(t_test[split_start:split_end], H_learned_aligned[split_start:split_end],
             label='pH-PINN Hamiltonian', color='red')
    plt.xlabel("$t$", fontsize=35)
    plt.ylabel("$H$", fontsize=35)
    plt.legend(fontsize=20, loc='upper right')
    plt.title("(a)", fontsize=40)
    plt.grid(True)
    plt.tick_params(axis='both', which='major', labelsize=30)
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, 'hamiltonian_comparison.png'), dpi=300)
    plt.savefig(os.path.join(output_dir, 'hamiltonian_comparison.eps'))

    # --- Plot 2: dH/dt Comparison ---
    plt.figure(figsize=(12, 8))
    plt.plot(t_test[split_start:split_end], dHdt_analytical_vis[split_start:split_end],
             label=r'Analytical $dH/dt$', linewidth=3, color='blue')
    # plt.plot(t_test[split_start:split_end], dHdt_pred_true[split_start:split_end]*(-1),
    #          label=r'$\nabla H \cdot \dot e_{\mathrm{true}}$',color='red')
    # plt.plot(t_test[split_start:split_end], dHdt_pred_autodiff[split_start:split_end]*(-1),
    #          label=r'$\nabla H \cdot \dot e_{\mathrm{autodiff}}$', color='red')
    plt.plot(t_test[split_start:split_end], dHdt_pred_pH[split_start:split_end]*(-1),
             label=r'pH-PINN $dH/dt$', color='red')
    plt.xlabel('$t$', fontsize=35);
    plt.ylabel(r'$dH/dt$', fontsize=35)
    plt.legend(fontsize=20, loc='upper right')
    plt.tight_layout()
    plt.grid(True)
    plt.tick_params(axis='both', which='major', labelsize=30)
    plt.title("(b)", fontsize=40)
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, 'dHdt_comparison.png'), dpi=300)
    plt.savefig(os.path.join(output_dir, 'dHdt_comparison.eps'))

    # --- Plot 3: Detailed Loss Histories ---
    plt.figure(figsize=(16, 9))
    min_val_epoch = np.argmin(val_losses)
    color_map = {
        'train': 'tab:blue',
        'val': 'tab:orange',
        'DynRes': 'tab:green',
        'j_structure': 'tab:brown',
        'r_structure': 'tab:pink',
        'conservative': 'tab:olive',
        'energy_rate': 'tab:cyan',
        'hamiltonian': 'tab:red'
    }

    plt.plot(train_losses, label='Total Training', color=color_map['train'], linewidth=2)
    plt.plot(val_losses, label='Total Validation', color=color_map['val'], linewidth=2)
    plt.plot(phys_losses, label='Dynamical System Residual', color='black', linewidth=2)
    plt.plot(j_structure_losses, label='J Fidelity', color=color_map['j_structure'], linewidth=2)
    plt.plot(r_structure_losses, label='R Fidelity', color=color_map['r_structure'], linewidth=2)
    plt.plot(conservative_losses, label='Conservative', color=color_map['conservative'], linewidth=2)
    plt.plot(dissipative_losses, label='Energy Rate', color=color_map['energy_rate'], linewidth=2)
    plt.plot(hamiltonian_losses, label='Hamiltonian (Monitor)', color=color_map['hamiltonian'], linewidth=2)

    plt.yscale('log')
    plt.xlabel('Epoch', fontsize=25)
    plt.ylabel('Loss (Log Scale)', fontsize=25)
    plt.legend(fontsize=18, loc='lower right', ncol=3)
    plt.grid(True, which="both", ls="--", alpha=0.6)
    plt.tick_params(axis='both', which='major', labelsize=20)
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, 'training_losses.png'), dpi=300)
    plt.savefig(os.path.join(output_dir, 'training_losses.eps'))


    # --- Plot 4: Error Derivative Fidelity (e_dot) ---
    n_states = e_dot_test.shape[1]
    fig, axes = plt.subplots(n_states, 1, figsize=(12, 12), sharex=True)
    state_labels_e_dot = [r'$\dot{e}_x$', r'$\dot{e}_y$', r'$\dot{e}_z$', r'$\dot{e}_u$', r'$\dot{e}_\phi$'][:n_states]
    for i in range(n_states):
        axes[i].plot(t_test[split_start:split_end], e_dot_test[split_start:split_end, i],
                     label='True Derivative', color='green', linewidth=2)
        # axes[i].plot(t_test[split_start:split_end], e_dot_autodiff[split_start:split_end, i],
        #              label='Autodiff', color='orange')
        # axes[i].plot(t_test[split_start:split_end], e_dot_from_equations[split_start:split_end, i],
        #              label='Differential Eq.', color='purple')
        axes[i].plot(t_test[split_start:split_end], e_dot_from_structure[split_start:split_end, i],
                     label='pH-PINN Derivative', color='red')
        axes[i].set_ylabel(state_labels_e_dot[i], fontsize=25)
        axes[i].grid(True)
        axes[i].tick_params(axis='both', which='major', labelsize=16)
    axes[0].legend(loc='upper right', fontsize=18)
    axes[-1].set_xlabel("$t$", fontsize=25)
    plt.tight_layout()
    fig.savefig(os.path.join(output_dir, 'error_derivative_fidelity.png'), dpi=300)
    fig.savefig(os.path.join(output_dir, 'error_derivative_fidelity.eps'))

    # --- Plot 5 & 6: Mean J and R Matrices (loaded from pickle) -------------
    J_mean = np.asarray(data['J_mean'])
    R_mean = np.asarray(data['R_mean'])

    var_labels = [r'$e_x$', r'$e_y$', r'$e_z$', r'$e_u$', r'$e_\phi$']

    def plot_matrix_with_numbers(mat, title, filename):
        plt.figure(figsize=(6.2, 5.4))
        ax = plt.gca()

        # mask zeros
        masked_mat = np.ma.masked_where(mat == 0, mat)

        # make a copy of the colormap and set how masked values look
        cmap = plt.cm.seismic.copy()
        cmap.set_bad(color=(0.9, 0.9, 0.9, 1.0))  # light gray for zeros

        im = ax.imshow(
            masked_mat,
            interpolation='nearest',
            aspect='equal',
            cmap=cmap
        )

        var_labels = [r'$e_x$', r'$e_y$', r'$e_z$', r'$e_u$', r'$e_\phi$']
        plt.title(title, fontsize=20)
        plt.xticks(np.arange(5), var_labels, rotation=0, fontsize=14)
        plt.yticks(np.arange(5), var_labels, fontsize=14)

        cbar = plt.colorbar(im, fraction=0.046, pad=0.04)

        # draw grid lines
        ax.set_xticks(np.arange(-0.5, mat.shape[1], 1), minor=True)
        ax.set_yticks(np.arange(-0.5, mat.shape[0], 1), minor=True)
        ax.grid(which='minor', color='k', linestyle='-', linewidth=0.7)
        ax.tick_params(which='minor', bottom=False, left=False)

        # add numbers
        norm = im.norm
        for i in range(mat.shape[0]):
            for j in range(mat.shape[1]):
                val = mat[i, j]
                if val == 0:
                    # matches the gray background
                    txt_color = 'black'
                    disp = "0"
                else:
                    rgba = cmap(norm(val))
                    r, g, b = rgba[:3]
                    luminance = 0.299 * r + 0.587 * g + 0.114 * b
                    txt_color = 'black' if luminance > 0.5 else 'white'
                    disp = f"{val:.3g}"
                plt.text(j, i, disp, ha='center', va='center',
                         color=txt_color, fontsize=12)

        plt.tight_layout()
        plt.savefig(os.path.join(output_dir, filename + ".png"), dpi=500)
        plt.savefig(os.path.join(output_dir, filename + ".eps"))
        plt.close()

    # Plot and save both matrices
    plot_matrix_with_numbers(J_mean, "(a)", "J_mean_matrix")
    plot_matrix_with_numbers(R_mean, "(b)", "R_mean_matrix")


    plt.close('all')
    print(f"\nâœ… All plots have been generated and saved to '{output_dir}'")


if __name__ == "__main__":
    main()